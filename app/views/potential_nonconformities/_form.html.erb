<% readonly = @potential_nonconformity.final? %>
<% review = @potential_nonconformity.review || @potential_nonconformity.control_objective_item.try(:review) %>
<% frozen = review.try(:is_frozen?) || @potential_nonconformity.repeated? %>
<% show_history_changes = @potential_nonconformity.status_change_history.size > 1 %>

<%= simple_form_for @potential_nonconformity do |f| %>
  <% content_for :js_extra do %>
    <%= raw("var lastWorkPaperCode = '#{next_potential_nonconformity_work_paper_code(
      @potential_nonconformity)}';") unless frozen %>
  <% end %>

  <%= render 'shared/error_explanation', f: f %>

  <div class="form-inputs">
    <div class="row">
      <div class="col-md-6">
        <div class="row">
          <div class="col-md-6">
            <%= f.input :review, label: Review.model_name.human(count: 1),
              input_html: { value: review.try(:identification), readonly: true } %>
          </div>
          <div class="col-md-6">
            <%= f.input :review_code, input_html: { maxlength: 255, readonly: true } %>
          </div>
        </div>
        <%= f.input :title, input_html: { autofocus: true, maxlength: 255, readonly: readonly } %>
        <div>
          <label for="potential_nonconformity_control_objective_item">
            <%= ControlObjective.model_name.human %>
          </label>
          <% if !readonly && !@potential_nonconformity.new_record? %>
            <%= f.input :control_objective_item, label: false, input_html: {
              value: @potential_nonconformity.control_objective_item.try(:control_objective_text),
              title: t('label.search'),
              autocomplete: :off,
              data: {
                autocomplete_params: ({ review_id: @potential_nonconformity.review.id } if @potential_nonconformity.review),
                autocomplete_url: auto_complete_for_control_objective_item_oportunities_path,
                autocomplete_id_target: '#control_objective_item_id'
              }
            } %>
          <% else %>
            <%= f.input :control_objective_name, label: false, input_html: {
              id: :potential_nonconformity_control_objective_item,
              value: "#{@potential_nonconformity.control_objective_item.control_objective_text}
                (#{@potential_nonconformity.control_objective_item.process_control.name})",
              readonly: true } %>
          <% end %>
          <%= f.input :control_objective_item_id, as: :hidden,
            input_html: { id: 'control_objective_item_id' } %>
        </div>
        <%= finding_repeated_of_label(f, readonly) %>
        <%= finding_repeated_of_if_field(f, readonly) %>
        <%= f.input :description, autofocus: true, input_html: { readonly: readonly } %>
      </div>
      <div class="col-md-6">
        <%= f.label :state, raw(PotentialNonconformity.human_attribute_name(:state) + ' ' +
            (show_history_changes ? finding_show_status_change_history(
              :finding_status_change_history) : ''))  %>
        <%= finding_status_field(f, true, readonly) %>

        <% if show_history_changes %>
          <%= render 'findings/history_changes', finding: @potential_nonconformity %>
        <% end %>

        <%= f.input :origination_date, as: :date_picker, label:
            PotentialNonconformity.human_attribute_name(:origination_date),
            input_html: { disabled: readonly } %>
        <%= f.input :answer, input_html: { readonly: readonly } %>
        <%= f.input :follow_up_date, as: :date_picker, label:
          PotentialNonconformity.human_attribute_name(:follow_up_date),
          input_html: { disabled: readonly } %>
        <%= f.input :solution_date, as: :date_picker, label:
          Finding.human_attribute_name(:solution_date),
          input_html: { disabled: readonly } %>

        <% if @potential_nonconformity.must_have_a_comment? %>
          <%= f.simple_fields_for :comments,
            @potential_nonconformity.comments.build(user: @auth_user) do |c_f| %>
            <%= c_f.input :comment %>
            <%= c_f.input :user_id, as: :hidden %>
          <% end %>
        <% end %>
        <%= f.input :audit_comments, input_html: { readonly: readonly } %>
      </div>
    </div>
  </div>

  <hr />
  <h4>
    <%= t('finding.responsibles', count: @potential_nonconformity.users.size) %>
  </h4>
  <div class="row">
    <div class="col-md-6">
      <h5><strong><%= User.model_name.human %></strong></h5>
    </div>
    <div class="col-md-2">
      <h5><%= FindingUserAssignment.human_attribute_name(:responsible_auditor) %></h5>
    </div>
    <div class="col-md-2">
      <h5><%= FindingUserAssignment.human_attribute_name(:process_owner) %></h5>
    </div>
  </div>

  <div id="finding_user_assignments">
    <%= f.simple_fields_for :finding_user_assignments do |fua_f| %>
      <%= render 'findings/finding_user_assignment', f: fua_f, readonly: readonly %>
    <% end %>

    <%= link_to_add_fields(t('finding.add_user'), f,
      :finding_user_assignments, 'findings/finding_user_assignment', {}, readonly: readonly
    ) unless readonly %>
  </div>

  <% unless (repeated_ancestors = @potential_nonconformity.repeated_ancestors).blank? %>
    <br />
    <h4>
      <%= t('finding.repeated_ancestors') %>
    </h4>

    <ul>
      <% repeated_ancestors.each do |repeated_ancestor| %>
        <li><%= repeated_ancestor %></li>
      <% end %>
    </ul>
  <% end %>

  <% unless (repeated_children = @potential_nonconformity.repeated_children).blank? %>
    <br />
    <h4>
      <%= t('finding.repeated_children') %>
    </h4>

    <ul>
      <% repeated_children.each do |repeated_child| %>
        <li><%= repeated_child %></li>
      <% end %>
    </ul>
  <% end %>

  <br />
  <h4>
    <%= t('finding.finding_relations') %>
  </h4>
  <div class="row">
    <div class="col-md-6">
      <h5><strong><%= FindingRelation.human_attribute_name :related_finding_id %></strong></h5>
    </div>
    <div class="col-md-4">
      <h5><strong><%= FindingRelation.human_attribute_name :description %></strong></h5>
    </div>
  </div>

  <div id="finding_relations">
    <%= f.simple_fields_for :finding_relations do |fr_f| %>
      <%= render 'findings/finding_relation', f: fr_f %>
    <% end %>

    <%= link_to_add_fields(t('finding.add_finding_relation'), f,
      :finding_relations, 'findings/finding_relation') unless frozen %>
  </div>

  <% unless @potential_nonconformity.inverse_finding_relations.blank? %>
    <br />
    <h4>
      <%= t('finding.inverse_finding_relations') %>
    </h4>

    <table class="table table-condensed table-striped">
      <thead>
        <tr>
          <th><%= FindingRelation.human_attribute_name :finding_id %></th>
          <th><%= FindingRelation.human_attribute_name :description %></th>
        </tr>
      </thead>
      <tbody>
        <% @potential_nonconformity.inverse_finding_relations.each do |ifr| %>
          <tr>
            <td><%= ifr.finding %></td>
            <td><%= ifr.description %></td>
          </tr>
        <% end %>
      </tbody>
    </table>
  <% end %>

  <% unless @potential_nonconformity.finding_answers.blank? %>
    <br />
    <h4>
      <%= t('finding.finding_answers') %>
    </h4>

    <table class="table table-condensed table-striped">
      <thead>
        <tr>
          <th><%= User.model_name.human %></th>
          <th><%= FindingAnswer.human_attribute_name :answer %></th>
          <th>
            <%= FindingAnswer.human_attribute_name :file_model %>
          </th>
          <th><%= FindingAnswer.human_attribute_name :created_at %></th>
        </tr>
      </thead>
      <tbody>
        <% @potential_nonconformity.finding_answers.each do |finding_answer| %>
          <tr>
            <td><%= finding_answer.user.full_name %></td>
            <td><%= simple_format finding_answer.answer %></td>
            <td>
              <%= finding_answer.file_model.try(:file?) ?
                link_to(t('label.download'), finding_answer.file_model.file.url) : '---' %>
            </td>
            <td>
              <%= l(finding_answer.created_at, :format => :long) if finding_answer.created_at %>
              <% if finding_answer.commitment_date %>
                <br />
                <br /><b><%= FindingAnswer.human_attribute_name(:commitment_date) %></b>:
                <br /><%= l(finding_answer.commitment_date, :format => :long) %>
              <% end %>
            </td>
          </tr>
        <% end %>
      </tbody>
    </table>
  <% end %>

  <br />
  <h4>
    <%= t('finding.work_papers') %>
  </h4>
  <div class="row">
    <div class="col-md-3">
      <h5><strong><%= WorkPaper.human_attribute_name 'name' %></strong></h5>
    </div>
    <div class="col-md-1">
      <h5><strong><%= WorkPaper.human_attribute_name 'code' %></strong></h5>
    </div>
    <div class="col-md-1">
      <h5><strong><%= WorkPaper.human_attribute_name 'number_of_pages' %></strong></h5>
    </div>
    <div class="col-md-4">
      <h5><strong><%= WorkPaper.human_attribute_name 'description' %></strong></h5>
    </div>
    <div class="col-md-2">
      <h5><strong><%= WorkPaper.human_attribute_name 'file_model' %></strong></h5>
    </div>
  </div>

  <div id="work_papers">
    <%= f.simple_fields_for :work_papers do |wp_f| %>
      <%= render 'work_papers/work_paper', f: wp_f, frozen: frozen %>
    <% end %>

    <%= link_to_add_fields(
      t('finding.add_work_paper'), f, :work_papers, 'work_papers/work_paper'
    ) unless frozen %>
  </div>

  <hr />

  <div class="form-actions">
    <div class="pull-right"><%= yield :form_actions %></div>
    <%= f.input :lock_version, as: :hidden %>
    <%= f.submit class: 'btn btn-primary', disabled: frozen %>
  </div>
<% end %>

<% if !@potential_nonconformity.new_record? && @potential_nonconformity.repeated_of && !readonly %>
  <% content_for :extra_html_bottom do %>
    <div id="inline_undo_reiteration" class="popup" style="display: none;">
      <%= button_to t('finding.undo_reiteration'),
        undo_reiteration_potential_nonconformity_path(@potential_nonconformity), :method => :patch %>
    </div>
  <% end %>
<% end %>
