<% if @query.blank? && @order_by.blank? && (@self_and_descendants.size > 1 || @related_users.size > 0 || @selected_user) %>
  <div class="filter" style="margin: 1em;">
    <div>
      <table>
        <tbody>
          <tr>
            <td style="padding-right: 1em; width: 90%;">
              <% if @selected_user %>
                <h2><%= @selected_user.full_name %></h2>
              <% else %>
                <%= label_tag :user_id_select, User.model_name.human, :class => :inline %>
                <%= select nil, :user_id,
                  sort_options_array((@self_and_descendants + @related_users).map { |d| [d.full_name_with_function, d.id.to_s] }),
                  {:prompt => true},
                  {:name => :user_id, :id => :user_id_select, :class => :inline_item} %>
              <% end %>
            </td>
            <td class="nowrap" style="text-align: right;">
              <%= link_to_if @selected_user, t('label.cancel'),
                findings_path(params[:completed]),
                {:style => 'margin-left: 1em;'} %>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
<% end %>
<%= render :partial => 'shared/search', :locals => {
  :options => {
    :columns_for_sort => Finding.columns_for_sort,
    :url => findings_path(:completed => params[:completed]),
    :extra_parameters => {:completed => params[:completed]}
  },
  :columns => @query.blank? ? Finding::COLUMNS_FOR_SEARCH.keys : @columns
} %>

<table class="list">
  <thead  id="column_headers">
    <tr>
      <th></th>
      <%= make_filterable_column Review.model_name.human, nil, 'review', 'issue_date' %>
      <%= make_filterable_column PlanItem.human_attribute_name(:project), {:expendable => true}, 'project' %>
      <%= make_filterable_column Finding.human_attribute_name(:review_code), nil, 'review_code' %>
      <%= make_filterable_column Finding.human_attribute_name(:description), {:expendable => true}, 'description' %>
      <%= make_not_available_column raw(Finding.human_attribute_name(:state) + show_inline_help_for(:finding_state)), :expendable => true %>
      <%= make_not_available_column Finding.human_attribute_name(
          params[:completed] == 'incomplete' ? :follow_up_date : :solution_date), :expendable => true %>
      <%= make_not_available_column Weakness.human_attribute_name(:risk), :expendable => true %>
      <%= make_not_available_column Finding.human_attribute_name(:finding_answers), :expendable => true %>
      <%= make_not_available_column raw(t('finding.has_work_papers') + show_inline_help_for(:finding_work_papers)), :expendable => true %>
      <th colspan="2" style="text-align: right;"><%= link_to_search %></th>
    </tr>
  </thead>

  <tbody>
    <% @findings.each do |finding| %>
      <tr class="<%= cycle('even', 'odd') %>">
        <td><%= finding_updated_at_text finding %></td>
        <td class="nowrap"><%= show_review_with_conclusion_status_as_abbr(
          finding.control_objective_item.review) %></td>
        <td class="expendable"><%= super_truncate(finding.control_objective_item.try(:review).try(:plan_item).try(:project), 20) %></td>
        <td class="nowrap"><%= show_finding_review_code_with_control_objective_as_abbr(finding) %></td>
        <td class="expendable"><%= super_truncate(finding.description, 30) %></td>
        <td class="expendable"><%= h finding.state_text %></td>
        <% if params[:completed] == 'complete' %>
          <td class="expendable"><%= h l(finding.solution_date, :format => :short) if finding.solution_date %></td>
        <% else %>
          <td class="expendable"><%= finding_follow_up_date_text(finding) %></td>
        <% end %>
        <td class="expendable"><%= h finding.respond_to?(:risk_text) ? finding.risk_text : '-' %></td>
        <td class="expendable"><%= h finding.finding_answers.count %></td>
        <td class="expendable"><%= t finding.work_papers.blank? ? 'label.no' : 'label.yes' %></td>
        <td><%= link_to_show finding_path(params[:completed], finding, :user_id => params[:user_id]) %></td>
        <td><%= link_to_edit(edit_finding_path('incomplete', finding, :user_id => params[:user_id])) if finding.pending? && (!@auth_user.can_act_as_audited? || finding.users.reload.include?(@auth_user)) %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<div id="links">
  <%= pagination_links @findings %>
  <%= link_to t('finding.download'),
    export_to_pdf_findings_path(
      request.query_parameters.merge(:_ts => Time.now.to_i)
    ) %> |
  <%= link_to t('finding.download_detailed'),
      export_to_pdf_findings_path(
        request.query_parameters.merge(:_ts => Time.now.to_i, :include_details => 1)
      ) %> |
  <%= link_to t('finding.download_xml'),
    findings_path(
      request.query_parameters.merge(:_ts => Time.now.to_i, :format => :xml)
    ) %>
  <div class="clear"></div>
</div>

<script type="text/javascript">
  $('#user_id_select').change(function() {
    if($(this).val()) {
      var url = '<%= findings_path(params[:completed]) %>';
      
      BrowserManipulation.changeLocation(url, {'user_id': $(this).val()});
    }
  });
</script>